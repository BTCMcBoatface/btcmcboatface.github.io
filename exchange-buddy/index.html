<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bitcoin Converter (Functional, No Design)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
  <h1>Bitcoin Converter</h1>

  <!-- Currency selector -->
  <label for="currency-selector">Add fiat exchange rate:</label>
  <select id="currency-selector">
    <option value="">Select currency...</option>
  </select>

  <!-- Future prediction toggle -->
  <label>
    <input type="checkbox" id="show-future-checkbox">
    Show Future Prediction
  </label>

  <!-- Future rate selector (shows only if prediction is on and at least one fiat is present) -->
  <div id="future-rate-row" style="display:none; margin: 1em 0;">
    <label for="future-currency-selector">Set future rate for: </label>
    <select id="future-currency-selector"></select>
    <input type="number" id="future-rate-input" min="0" step="any" placeholder="Future rate (per 1 BTC)">
    <span id="future-rate-symbol"></span>
  </div>

  <!-- Conversion table -->
  <table id="conversion-table" border="1" cellspacing="0" cellpadding="4">
    <thead>
      <tr>
        <th>Unit/Currency</th>
        <th>Current</th>
        <th id="future-th" style="display:none;">Future</th>
        <th>Remove</th>
      </tr>
    </thead>
    <tbody id="conversion-table-body">
      <!-- Rows will be populated by JS -->
    </tbody>
  </table>

  <div id="last-updated"></div>

  <script>
    // --- Data storage ---
    let exchangeRates = {};
    let currencyMetadata = {};
    let currenciesConfig = [];
    let activeCurrencies = []; // Array for order
    let futureRates = {}; // { currencyCode: rate }
    let currentFutureCurrency = null; // For the future dropdown

    // --- Core units ---
    const coreUnits = [
      { key: 'btc', label: 'BTC', symbol: '₿', step: '0.00000001' },
      { key: 'bits', label: 'Bits', symbol: '', step: '0.01' },
      { key: 'sats', label: 'Sats', symbol: '', step: '1' },
      { key: 'usd', label: 'USD', symbol: '', step: '0.01' }
    ];

    // --- Utility functions ---
    function getInputId(key, future = false) {
      return `${key}-input${future ? '-future' : ''}`;
    }

    function getCurrencyLabel(code) {
      const data = currencyMetadata[code];
      return data ? `${data.emoji || ''} ${code} ${data.symbol || ''}` : code;
    }

    function getCurrencySymbol(code) {
      const data = currencyMetadata[code];
      return data ? data.symbol || '' : '';
    }

    // --- Initialization ---
    async function loadData() {
      // Load exchange rates
      const ratesRes = await fetch('exchange-rates.json');
      const ratesData = await ratesRes.json();
      exchangeRates = ratesData.rates;
      const lastUpdated = new Date(ratesData.timestamp * 1000);
      document.getElementById('last-updated').textContent =
        `Fiat exchange rates last updated: ${lastUpdated.toLocaleString()}`;

      // Load metadata
      const metaRes = await fetch('fiat-country-flags.json');
      const metaData = await metaRes.json();
      currencyMetadata = {};
      metaData.currencies.forEach(c => { currencyMetadata[c.code] = c; });

      // Load configured currencies
      const configRes = await fetch('currencies.json');
      const configData = await configRes.json();
      currenciesConfig = configData.currencies;

      // Setup CAD by default
      if (!activeCurrencies.includes('CAD')) activeCurrencies.unshift('CAD');

      populateCurrencySelector();
      renderFutureCurrencySelector();
      renderTable();
    }

    function populateCurrencySelector() {
      const selector = document.getElementById('currency-selector');
      selector.innerHTML = '<option value="">Select currency...</option>';
      // Show all config currencies, even CAD
      currenciesConfig.slice().sort().forEach(code => {
        const label = getCurrencyLabel(code);
        const option = document.createElement('option');
        option.value = code;
        option.textContent = label;
        selector.appendChild(option);
      });
    }

    function renderFutureCurrencySelector() {
      const sel = document.getElementById('future-currency-selector');
      sel.innerHTML = '';
      // Only show currencies that are visible
      activeCurrencies.forEach(code => {
        const opt = document.createElement('option');
        opt.value = code;
        opt.textContent = getCurrencyLabel(code);
        sel.appendChild(opt);
      });
      // Default to first active if not set
      if (!currentFutureCurrency || !activeCurrencies.includes(currentFutureCurrency)) {
        currentFutureCurrency = activeCurrencies[0] || null;
      }
      sel.value = currentFutureCurrency;
      // Set symbol
      document.getElementById('future-rate-symbol').textContent =
        currentFutureCurrency ? getCurrencySymbol(currentFutureCurrency) + ' per 1 BTC' : '';
      // Set input value
      document.getElementById('future-rate-input').value =
        currentFutureCurrency && futureRates[currentFutureCurrency]
          ? futureRates[currentFutureCurrency]
          : '';
    }

    // --- Table Rendering ---
    function renderTable() {
      const tbody = document.getElementById('conversion-table-body');
      tbody.innerHTML = '';
      // Render core units
      coreUnits.forEach(unit => {
        const tr = document.createElement('tr');
        // Label
        const tdLabel = document.createElement('td');
        tdLabel.textContent = unit.symbol ? `${unit.symbol} ${unit.label}` : unit.label;
        tr.appendChild(tdLabel);
        // Current input
        const tdCurrent = document.createElement('td');
        tdCurrent.appendChild(
          createInputField(unit.key, false, unit.step, unit.label)
        );
        tr.appendChild(tdCurrent);
        // Future output (no label)
        const tdFuture = document.createElement('td');
        tdFuture.style.display = showFuture() ? '' : 'none';
        tdFuture.appendChild(
          createInputField(unit.key, true, unit.step, unit.label, true)
        );
        tr.appendChild(tdFuture);
        // Remove (not for core units)
        tr.appendChild(document.createElement('td'));
        tbody.appendChild(tr);
      });
      // Render each active fiat currency
      activeCurrencies.forEach(code => {
        // Don't repeat USD (already in core units)
        if (code === 'USD') return;
        const tr = document.createElement('tr');
        // Label
        const tdLabel = document.createElement('td');
        tdLabel.textContent = getCurrencyLabel(code);
        tr.appendChild(tdLabel);
        // Current input
        const tdCurrent = document.createElement('td');
        tdCurrent.appendChild(
          createInputField(code.toLowerCase(), false, '0.01', code)
        );
        tr.appendChild(tdCurrent);
        // Future output
        const tdFuture = document.createElement('td');
        tdFuture.style.display = showFuture() ? '' : 'none';
        tdFuture.appendChild(
          createInputField(code.toLowerCase(), true, '0.01', code, true)
        );
        tr.appendChild(tdFuture);
        // Remove button
        const tdRemove = document.createElement('td');
        if (code !== 'CAD') {
          const btn = document.createElement('button');
          btn.textContent = '×';
          btn.setAttribute('aria-label', `Remove ${code}`);
          btn.onclick = () => {
            activeCurrencies = activeCurrencies.filter(c => c !== code);
            // Remove future rate if present
            delete futureRates[code];
            renderFutureCurrencySelector();
            renderTable();
            recalculateAll();
          };
          tdRemove.appendChild(btn);
        }
        tr.appendChild(tdRemove);
        tbody.appendChild(tr);
      });
      // Show/hide future column header
      document.getElementById('future-th').style.display = showFuture() ? '' : 'none';
    }

    function createInputField(key, future, step, label, readOnly = false) {
      const input = document.createElement('input');
      input.type = 'number';
      input.step = step;
      input.id = getInputId(key, future);
      input.name = getInputId(key, future);
      input.setAttribute('aria-label', (future ? 'Future ' : 'Current ') + label);
      input.readOnly = !!readOnly;
      // Only current inputs trigger recalculation
      if (!future && !readOnly) {
        input.addEventListener('input', (e) => {
          if (e.target.value !== '') {
            convertFromSource(key, parseFloat(e.target.value));
          }
        });
      }
      return input;
    }

    // --- Event Handlers ---
    document.getElementById('currency-selector').addEventListener('change', function(e) {
      const code = e.target.value;
      if (code && !activeCurrencies.includes(code)) {
        activeCurrencies.push(code);
        renderFutureCurrencySelector();
        renderTable();
        recalculateAll();
      }
      e.target.value = '';
    });

    document.getElementById('show-future-checkbox').addEventListener('change', function() {
      document.getElementById('future-th').style.display =
        this.checked ? '' : 'none';
      document.getElementById('future-rate-row').style.display =
        (this.checked && activeCurrencies.length > 0) ? '' : 'none';
      renderTable();
      recalculateAll();
    });

    document.getElementById('future-currency-selector').addEventListener('change', function(e) {
      currentFutureCurrency = e.target.value;
      document.getElementById('future-rate-symbol').textContent =
        currentFutureCurrency ? getCurrencySymbol(currentFutureCurrency) + ' per 1 BTC' : '';
      document.getElementById('future-rate-input').value =
        futureRates[currentFutureCurrency] || '';
    });

    document.getElementById('future-rate-input').addEventListener('input', function(e) {
      const val = parseFloat(e.target.value);
      if (currentFutureCurrency) {
        if (!isNaN(val) && val > 0) {
          futureRates[currentFutureCurrency] = val;
        } else {
          delete futureRates[currentFutureCurrency];
        }
        recalculateAll();
      }
    });

    // --- Conversion logic ---
    function showFuture() {
      return document.getElementById('show-future-checkbox').checked;
    }

    function convertFromSource(sourceKey, value) {
      // Convert value to BTC
      let btcValue;
      if (sourceKey === 'btc') {
        btcValue = value;
      } else if (sourceKey === 'bits') {
        btcValue = value / 1e6;
      } else if (sourceKey === 'sats') {
        btcValue = value / 1e8;
      } else if (sourceKey === 'usd') {
        btcValue = value / (1 / exchangeRates['BTC']);
      } else {
        // fiat
        const upper = sourceKey.toUpperCase();
        const rateUsd = exchangeRates[upper];
        if (!rateUsd) return;
        const usdValue = value / rateUsd;
        btcValue = usdValue / (1 / exchangeRates['BTC']);
      }
      recalculateAll(btcValue, sourceKey);
    }

    function recalculateAll(btcValueOverride = null, skipKey = null) {
      // Determine BTC value
      let btcValue = btcValueOverride;
      // If no override, try to get from BTC input
      if (btcValue == null) {
        const v = document.getElementById(getInputId('btc')).value;
        btcValue = v ? parseFloat(v) : 0;
      }
      // --- CORE UNITS ---
      coreUnits.forEach(unit => {
        // Skip updating the field that was just input
        if (skipKey === unit.key) return;
        let val = '';
        if (unit.key === 'btc') {
          val = btcValue;
        } else if (unit.key === 'bits') {
          val = btcValue * 1e6;
        } else if (unit.key === 'sats') {
          val = btcValue * 1e8;
        } else if (unit.key === 'usd') {
          val = btcValue * (1 / exchangeRates['BTC']);
        }
        document.getElementById(getInputId(unit.key)).value =
          typeof val === 'number' && !isNaN(val)
            ? (unit.key === 'btc'
                ? val.toLocaleString('en-US', { minimumFractionDigits: 8, maximumFractionDigits: 8 })
                : val.toFixed(unit.key === 'usd' ? 2 : 0))
            : '';
        // Future column
        if (showFuture()) {
          let futureVal = '';
          let futureRate = null;
          if (unit.key === 'btc') {
            futureVal = btcValue;
          } else if (unit.key === 'bits') {
            futureVal = btcValue * 1e6;
          } else if (unit.key === 'sats') {
            futureVal = btcValue * 1e8;
          } else if (unit.key === 'usd') {
            // Use future rate if set
            futureRate = futureRates['USD'];
            if (futureRate) {
              futureVal = btcValue * futureRate;
            } else {
              futureVal = btcValue * (1 / exchangeRates['BTC']);
            }
          }
          document.getElementById(getInputId(unit.key, true)).value =
            typeof futureVal === 'number' && !isNaN(futureVal)
              ? (unit.key === 'btc'
                  ? futureVal.toLocaleString('en-US', { minimumFractionDigits: 8, maximumFractionDigits: 8 })
                  : futureVal.toFixed(unit.key === 'usd' ? 2 : 0))
              : '';
        }
      });
      // --- FIAT CURRENCIES ---
      activeCurrencies.forEach(code => {
        const key = code.toLowerCase();
        if (key === 'usd') return; // already handled above
        // Skip updating the field that was just input
        if (skipKey === key) return;
        const rate = exchangeRates[code];
        if (!rate) return;
        const usdValue = btcValue * (1 / exchangeRates['BTC']);
        const currentVal = usdValue * rate;
        document.getElementById(getInputId(key)).value =
          typeof currentVal === 'number' && !isNaN(currentVal)
            ? currentVal.toFixed(2)
            : '';
        // Future column
        if (showFuture()) {
          let futureVal = '';
          let futureRate = futureRates[code];
          if (futureRate) {
            futureVal = btcValue * futureRate;
          } else {
            futureVal = usdValue * rate;
          }
          document.getElementById(getInputId(key, true)).value =
            typeof futureVal === 'number' && !isNaN(futureVal)
              ? futureVal.toFixed(2)
              : '';
        }
      });
    }

    // --- Show/hide future controls as needed ---
    function updateFutureControls() {
      const row = document.getElementById('future-rate-row');
      row.style.display =
        showFuture() && activeCurrencies.length > 0 ? '' : 'none';
    }

    // --- Load preferences (if any) ---
    function loadPreferences() {
      const saved = localStorage.getItem('bitcoinConverterPrefs');
      if (saved) {
        try {
          const prefs = JSON.parse(saved);
          if (Array.isArray(prefs.activeCurrencies)) {
            activeCurrencies = prefs.activeCurrencies.slice();
            if (!activeCurrencies.includes('CAD')) activeCurrencies.unshift('CAD');
          }
        } catch {}
      }
    }

    function savePreferences() {
      localStorage.setItem('bitcoinConverterPrefs', JSON.stringify({
        activeCurrencies
      }));
    }

    // --- Initial setup ---
    document.addEventListener('DOMContentLoaded', async function() {
      loadPreferences();
      await loadData();
      document.getElementById('show-future-checkbox').checked = false;
      updateFutureControls();
      renderTable();
      recalculateAll();

      // Save prefs on currency change
      const saveAndRender = () => {
        savePreferences();
        renderFutureCurrencySelector();
        renderTable();
        recalculateAll();
        updateFutureControls();
      };
      // Listen for changes to active currencies
      const observer = new MutationObserver(saveAndRender);
      observer.observe(document.getElementById('conversion-table-body'), { childList: true, subtree: true });
    });

  </script>
</body>
</html>
